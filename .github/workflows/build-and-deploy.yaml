name: Build and Deploy to AWS Dev

on:
  push:
    branches:
      - main

permissions:
  contents: read

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # Common Env Variables
  AWS_ACCESS_KEY_ID: "${{ secrets.AWS_ACCESS_KEY_ID }}"
  AWS_SECRET_ACCESS_KEY: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
  AWS_ACCOUNT: "${{ vars.AWS_ACCOUNT }}"
  AWS_REGION: "${{ vars.AWS_REGION }}"
  STATE_BUCKET: "${{ vars.STATE_BUCKET }}"
  ENVIRONMENT: dev
  NICKNAME: strapi
  WORKING_DIRECTORY: terraform/deployments/app
  DEPLOYMENT: app
  TF_VAR_FILE: ${{ github.workspace }}/terraform/environments/dev.tfvars
  # Project Specific Env Variables
  DESIRED_COUNT: "${{ vars.DESIRED_COUNT }}"

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-publish:
    name: Build & Publish Docker Image
    runs-on: ubuntu-latest
    environment: dev
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      checks: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      # ESLint and Prettier must be in `package.json`
      - name: Install Node.js Dependencies
        uses: borales/actions-yarn@v4
        with:
          cmd: install

      - name: Run linters
        uses: wearerequired/lint-action@v2
        with:
          eslint: true
          prettier: true

      - name: Run Unit Test (Jest)
        uses: borales/actions-yarn@v4
        with:
          cmd: test

      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` "meta" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see "[Usage](https://github.com/docker/build-push-action#usage)" in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the "meta" step.
      - name: Build and push Docker image
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          file: ./Dockerfile.prod
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    environment: dev
    needs: [build-and-publish]
    env:
      #this is needed since we are running terraform with read-only permissions
      ARM_SKIP_PROVIDER_REGISTRATION: true
    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v4

      # Install the latest version of the Terraform CLI
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          terraform init -reconfigure \
            -backend-config="bucket=$STATE_BUCKET" \
            -backend-config="region=$AWS_REGION" \
            -backend-config="key=$NICKNAME/$ENVIRONMENT/$AWS_REGION/$DEPLOYMENT.tfstate"

      # Checks that all Terraform configuration files adhere to a canonical format
      # Will fail the build if not
      - name: Terraform Format
        run: terraform fmt -check

      # Generates an execution plan for Terraform
      # An exit code of 0 indicated no changes, 1 a terraform failure, 2 there are pending changes.
      - name: Terraform Plan
        id: tf-plan
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          export exitcode=0
          terraform plan -var-file $TF_VAR_FILE  \
            -var="aws_region=$AWS_REGION" \
            -var="environment=$ENVIRONMENT" \
            -var="nickname=$NICKNAME" \
            -var="state_bucket=$STATE_BUCKET" \
            -var="image=$IMAGE_NAME" \
            -var="desired_count=$DESIRED_COUNT" \
            -detailed-exitcode -no-color -out tfplan || export exitcode=$?

          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

          if [ $exitcode -eq 1 ]; then
            echo Terraform Plan Failed!
            exit 1
          else 
            exit 0
          fi

      # Save plan to artifacts
      - name: Publish Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: tfplan
          path: ${{ env.WORKING_DIRECTORY }}/tfplan

      # Create string output of Terraform Plan
      - name: Create String Output
        id: tf-plan-string
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          TERRAFORM_PLAN=$(terraform show -no-color tfplan)

          delimiter="$(openssl rand -hex 8)"
          echo "summary<<${delimiter}" >> $GITHUB_OUTPUT
          echo "## Terraform Plan Output" >> $GITHUB_OUTPUT
          echo "<details><summary>Click to expand</summary>" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo '```terraform' >> $GITHUB_OUTPUT
          echo "$TERRAFORM_PLAN" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "</details>" >> $GITHUB_OUTPUT
          echo "${delimiter}" >> $GITHUB_OUTPUT

      # Publish Terraform Plan as task summary
      - name: Publish Terraform Plan to Task Summary
        env:
          SUMMARY: ${{ steps.tf-plan-string.outputs.summary }}
        run: |
          echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY

  terraform-apply:
    name: Terraform Apply
    if: needs.terraform-plan.outputs.tfplanExitCode == 2
    runs-on: ubuntu-latest
    environment: dev
    needs: [terraform-plan]

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v4

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false
          terraform_version: ${{ env.TF_VERSION }}

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          terraform init -reconfigure \
          -backend-config="bucket=$STATE_BUCKET" \
          -backend-config="region=$AWS_REGION" \
          -backend-config="key=$NICKNAME/$ENVIRONMENT/$AWS_REGION/$DEPLOYMENT.tfstate"

      # Download saved plan from artifacts
      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: tfplan
          path: ${{ env.WORKING_DIRECTORY }}

      # Terraform Apply
      - name: Terraform Apply
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: terraform apply -auto-approve tfplan
